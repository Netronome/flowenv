/*
 * Copyright (C) 2015-2018,  Netronome Systems, Inc.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @file          lib/nfp/_c/macstats.c
 * @brief         Read, and optionally accumulate, per port and per channel
 *                MAC statistics.
 */

/* Autogenerated header files */
#if defined(__NFP_IS_38XX)
    #include <nfp3800/nfp_me.h>

    /* Definitions for MACs/Ports numbers */
    #define MAX_MAC_NUMBER      0
    #define MAX_PORT_NUMBER     19
    #define PORTS_PER_MAC_CORE  10
#elif defined(__NFP_IS_6XXX)
    #include <nfp6000/nfp_me.h>

    /* Definitions for MACs/Ports numbers */
    #define MAX_MAC_NUMBER      1
    #define MAX_PORT_NUMBER     23
    #define PORTS_PER_MAC_CORE  12
#else
    #error "Please select valid chip target."
#endif

#include <assert.h>
#include <nfp/macstats.h>
#include <nfp/me.h>
#include <nfp/mem_atomic.h>
#include <nfp/xpb.h>


/* Definitions for Channels numbers */
#define MAX_CHANNEL_NUMBER  127
/* Base addresses for MAC stats access */
#define MACSTATS_BASE           0x100000
#define MACSTATS_HYD0_PORT_BASE (MACSTATS_BASE + 0)
#define MACSTATS_HYD1_PORT_BASE (MACSTATS_BASE + 0x1000)
#define MACSTATS_CHANNEL_BASE   (MACSTATS_BASE + 0x10000)
/* Per port and per channel stats size */
#define MACSTATS_PER_CORE_PORT_SIZE 4096
#define MACSTATS_PER_PORT_SIZE      256
#define MACSTATS_PER_CHANNEL_SIZE   256

#define MACSTATS_CHAN_ADDR_HI(_mac) ((mac) << 30)
#define MACSTATS_CHAN_ADDR_LO(_ch) (MACSTATS_CHANNEL_BASE + \
                                    (_ch) * MACSTATS_PER_CHANNEL_SIZE)

#define MACSTATS_PORT_ADDR_HI(_mac) ((mac) << 30)
#define MACSTATS_PORT_ADDR_LO(_core, _seg) \
                (MACSTATS_BASE + (_core)* MACSTATS_PER_CORE_PORT_SIZE + \
                 (_seg) * MACSTATS_PER_PORT_SIZE)

/* Sleep between each mac head counter read to reduce the short burst CPP
 * accesses. */
#ifndef MAC_HEAD_DROP_SLEEP
#define MAC_HEAD_DROP_SLEEP 2000
#endif

/* Chink of mac stats in bytes that get operated on per retrieve iteration */
#define STATS_CHUNK 32

/* Read 8 stats values from nbi and write to destination */
__intrinsic static void
mac_stats_load(__gpr unsigned int src_hi, __gpr unsigned int src_lo,
               __gpr unsigned int dst_hi, __gpr unsigned int dst_lo)
{
    __xrw unsigned int stats[8];
    SIGNAL sig;

    __asm {
        nbi[read, stats[0], src_hi, <<8, src_lo, 4], ctx_swap[sig];
        alu[stats[0], --, B, stats[1]];
        alu[stats[1], --, B, stats[0]];
        alu[stats[2], --, B, stats[3]];
        alu[stats[3], --, B, stats[2]];
        alu[stats[4], --, B, stats[5]];
        alu[stats[5], --, B, stats[4]];
        alu[stats[6], --, B, stats[7]];
        alu[stats[7], --, B, stats[6]];
        mem[write, stats[0], dst_hi, <<8, dst_lo, 4], ctx_swap[sig];
    }
}

/* Read 8 stats values from nbi and prepare output buffer */
__intrinsic static void
mac_stats_fetch(__xread unsigned int *stats_xr,
                __xwrite unsigned int *stats_xw,
                __gpr unsigned int src_hi, __gpr unsigned int src_lo)
{
    SIGNAL sig;

    __asm {
        nbi[read, *stats_xr, src_hi, <<8, src_lo, 4], ctx_swap[sig];
        alu[stats_xw[0], --, B, stats_xr[0]];
        alu[stats_xw[1], --, B, 0];
        alu[stats_xw[2], --, B, stats_xr[1]];
        alu[stats_xw[3], --, B, 0];
        alu[stats_xw[4], --, B, stats_xr[2]];
        alu[stats_xw[5], --, B, 0];
        alu[stats_xw[6], --, B, stats_xr[3]];
        alu[stats_xw[7], --, B, 0];
        alu[stats_xw[8], --, B, stats_xr[4]];
        alu[stats_xw[9], --, B, 0];
        alu[stats_xw[10], --, B, stats_xr[5]];
        alu[stats_xw[11], --, B, 0];
        alu[stats_xw[12], --, B, stats_xr[6]];
        alu[stats_xw[13], --, B, 0];
        alu[stats_xw[14], --, B, stats_xr[7]];
        alu[stats_xw[15], --, B, 0];
    }
}
/* Write 8 stats values to destination */
__intrinsic void
mac_stats_commit(__xwrite uint32_t *stats_xw,
                 unsigned int dst_hi, unsigned int dst_lo)
{
    SIGNAL sig;
    __xwrite uint32_t *xw;
    __gpr unsigned int dst_lo2 = dst_lo + 32;

    xw = stats_xw;
    __asm mem[add64, *xw, dst_hi, <<8, dst_lo, 4], ctx_swap[sig];
    xw = xw + 8;
    __asm mem[add64, *xw, dst_hi, <<8, dst_lo2, 4], ctx_swap[sig];
}

int
macstats_port_read(unsigned int mac, unsigned int port,
                   __mem40 struct macstats_port *port_stats)
{
    unsigned char core;
    unsigned char seg;
    __gpr unsigned int src_hi;
    __gpr unsigned int src_lo;
    __gpr unsigned int dst_hi;
    __gpr unsigned int dst_lo;
    __gpr unsigned int off;

    if (mac > MAX_MAC_NUMBER)
        return -1;

    if (port > MAX_PORT_NUMBER)
        return -1;

    if (port >= PORTS_PER_MAC_CORE)
        core = 1;
    else
        core = 0;
    seg = port - (core * PORTS_PER_MAC_CORE);

    src_hi = MACSTATS_PORT_ADDR_HI(mac);
    src_lo = MACSTATS_PORT_ADDR_LO(core, seg);

    dst_hi = (((unsigned long long)port_stats) >> 8) & 0xFF000000;
    dst_lo = ((unsigned long long)port_stats) & 0xFFFFFFFF;

    for (off = 0; off < sizeof(struct macstats_port); off += 32)
        mac_stats_load(src_hi, src_lo + off, dst_hi, dst_lo + off);

    return 0;
}

__intrinsic void static
stats_hi_fixup(__xread unsigned int stats_xr[8],
               __xwrite unsigned int stats_xw[16],
               unsigned int hi_in_offb,
               unsigned int val_out_offb,
               unsigned int offb,
               unsigned int chunk_size)
{
    unsigned int lw_out, lw_in;

    lw_in = (hi_in_offb % chunk_size) / sizeof(uint32_t);

    /* there are two 'out' words for every 'in' word */
    lw_out = (val_out_offb % (chunk_size * 2)) / sizeof(uint32_t);
    lw_out += 1; /* atomic engine want high in the odd word */

    /* write in the hi word, also clear the unused hi word */
    stats_xw[lw_out] = stats_xr[lw_in];
    stats_xw[lw_in * 2] = 0;
}

__intrinsic void static
stats_patchup(__xwrite unsigned int stats_xw[16],
              unsigned int val_out_offb,
              uint32_t patch_value,
              unsigned int offb,
              unsigned int chunk_size)
{
    unsigned int lw_out, lw_in;

    /* first we see if the out value is in the chunk;
     * NOTE: there are two 'out' words for every 'in' word hence the "* 2"
     * NOTE: we check the patch value to allow the compiler to optimize out
     *       the patchup, O accumulation means do nothing
     */
    if (__is_ct_const(patch_value) && patch_value == 0)
        return;

    lw_out = (val_out_offb % (chunk_size * 2)) / sizeof(uint32_t);
    stats_xw[lw_out] = patch_value;
}

__intrinsic int
macstats_port_accum_all(unsigned int mac, unsigned int port,
                        __mem40 struct macstats_port_accum *port_stats,
                        uint32_t rx_mac_head_drops, uint32_t tx_queue_drops)
{
    __xread unsigned int stats_xr[8];
    __xwrite unsigned int stats_xw[16];
    unsigned char core;
    unsigned char seg;
    __gpr unsigned int src_hi;
    __gpr unsigned int src_lo;
    __gpr unsigned int dst_hi;
    __gpr unsigned int dst_lo;
    __gpr unsigned int off;
    int ret;

    /* this code expects RxMacHeadDrop and TxQueueDrop to be in the
     * same chunk, enforce with a ct assert
     */
    ctassert(offsetof(struct macstats_port_accum, TxQueueDrop) / (STATS_CHUNK * 2) ==
             offsetof(struct macstats_port_accum, RxMacHeadDrop) / (STATS_CHUNK * 2));


    if (mac > MAX_MAC_NUMBER) {
        ret = -1;
        goto out;
    }

    if (port > MAX_PORT_NUMBER) {
        ret = -1;
        goto out;
    }


    if (port >= PORTS_PER_MAC_CORE)
        core = 1;
    else
        core = 0;
    seg = port - (core * PORTS_PER_MAC_CORE);

    src_hi = MACSTATS_PORT_ADDR_HI(mac);
    src_lo = MACSTATS_PORT_ADDR_LO(core, seg);

    dst_hi = (((unsigned long long)port_stats) >> 8) & 0xFF000000;
    dst_lo = ((unsigned long long)port_stats) & 0xFFFFFFFF;

    for (off = 0; off < sizeof(struct macstats_port); off += STATS_CHUNK) {
        /* get the NBI stats */
        mac_stats_fetch(stats_xr, stats_xw, src_hi, src_lo + off);

        /* Do high word fixup and patch in non-nbi values */
        if (off / STATS_CHUNK ==
                offsetof(struct macstats_port, RxPIfInOctetsHi) / STATS_CHUNK) {
            stats_hi_fixup(stats_xr, stats_xw,
                           offsetof(struct macstats_port, RxPIfInOctetsHi),
                           offsetof(struct macstats_port_accum, RxPIfInOctets),
                           off, STATS_CHUNK);
        } else if (off / STATS_CHUNK ==
                offsetof(struct macstats_port, TxPIfOutOctetsLo) / STATS_CHUNK) {
            stats_hi_fixup(stats_xr, stats_xw,
                           offsetof(struct macstats_port, TxPIfOutOctetsHi),
                           offsetof(struct macstats_port_accum, TxPIfOutOctets),
                           off, STATS_CHUNK);
        } else if (off / STATS_CHUNK ==
                offsetof(struct macstats_port_accum, RxMacHeadDrop) / (STATS_CHUNK * 2)) {
            stats_patchup(stats_xw,
                          offsetof(struct macstats_port_accum, RxMacHeadDrop),
                          rx_mac_head_drops, off, STATS_CHUNK);
            stats_patchup(stats_xw,
                          offsetof(struct macstats_port_accum, TxQueueDrop),
                          tx_queue_drops, off, STATS_CHUNK);
        }

        mac_stats_commit(stats_xw, dst_hi, dst_lo + 2*off);
    }
out:
    return ret;
}


int
macstats_port_accum(unsigned int mac, unsigned int port,
                    __mem40 struct macstats_port_accum *port_stats)
{
    return macstats_port_accum_all(mac, port, port_stats, 0, 0);
}

int
macstats_channel_read(unsigned int mac, unsigned int channel,
                      __mem40 struct macstats_channel *channel_stats)
{
    __gpr unsigned int src_hi;
    __gpr unsigned int src_lo;
    __gpr unsigned int src_lo_base;
    __gpr unsigned int dst_hi;
    __gpr unsigned int dst_lo;
    __gpr unsigned int off;

    if (mac > MAX_MAC_NUMBER)
        return -1;

    if (channel > MAX_CHANNEL_NUMBER)
        return -1;

    src_hi = MACSTATS_CHAN_ADDR_HI(mac);
    src_lo = MACSTATS_CHAN_ADDR_LO(channel);

    dst_hi = (((unsigned long long)channel_stats) >> 8) & 0xFF000000;
    dst_lo = ((unsigned long long)channel_stats) & 0xFFFFFFFF;

    for (off = 0; off < sizeof(struct macstats_channel); off += STATS_CHUNK)
        mac_stats_load(src_hi, src_lo + off, dst_hi, dst_lo + off);

    return 0;
}

__intrinsic int
macstats_channel_accum(unsigned int mac, unsigned int channel,
                       __mem40 struct macstats_channel_accum *channel_stats)
{
    __xread unsigned int stats_xr[8];
    __xwrite unsigned int stats_xw[16];
    __gpr unsigned int src_hi;
    __gpr unsigned int src_lo;
    __gpr unsigned int dst_hi;
    __gpr unsigned int dst_lo;
    __gpr unsigned int off;

    /* RxCIfInOctetsLo and RxCStatsOctetsLo should be in the same chunk */
    ctassert(offsetof(struct macstats_channel, RxCIfInOctetsHi) / STATS_CHUNK ==
             offsetof(struct macstats_channel, RxCStatsOctetsHi) / STATS_CHUNK);

    src_hi = MACSTATS_CHAN_ADDR_HI(mac);
    src_lo = MACSTATS_CHAN_ADDR_LO(channel);

    if (mac > MAX_MAC_NUMBER)
        return -1;

    if (channel > MAX_CHANNEL_NUMBER)
        return -1;

    dst_hi = (((unsigned long long)channel_stats) >> 8) & 0xFF000000;
    dst_lo = ((unsigned long long)channel_stats) & 0xFFFFFFFF;

    for (off = 0; off < sizeof(struct macstats_channel); off += STATS_CHUNK) {
        __xread uint32_t foo;
        __xwrite uint32_t foo2;

        mac_stats_fetch(stats_xr, stats_xw, src_hi, src_lo + off);

        /* Do high word fixup */
        if (off / STATS_CHUNK ==
                    offsetof(struct macstats_channel, RxCIfInOctetsLo) / STATS_CHUNK) {
            stats_hi_fixup(stats_xr, stats_xw,
                           offsetof(struct macstats_channel, RxCIfInOctetsHi),
                           offsetof(struct macstats_channel_accum, RxCIfInOctets),
                           off, STATS_CHUNK);
            stats_hi_fixup(stats_xr, stats_xw,
                           offsetof(struct macstats_channel, RxCStatsOctetsHi),
                           offsetof(struct macstats_channel_accum, RxCStatsOctets),
                           off, STATS_CHUNK);
        } else if (off / STATS_CHUNK ==
                    offsetof(struct macstats_channel, TxCIfOutOctetsLo) / STATS_CHUNK) {
            stats_hi_fixup(stats_xr, stats_xw,
                           offsetof(struct macstats_channel, TxCIfOutOctetsHi),
                           offsetof(struct macstats_channel_accum, TxCIfOutOctets),
                           off, STATS_CHUNK);
        }

        mac_stats_commit(stats_xw, dst_hi, dst_lo + 2*off);
    }


    return 0;
}

#if defined(__NFP_IS_6XXX)

__intrinsic int
__macstats_head_drop_accum(unsigned int nbi, unsigned int core,
                           unsigned short ports_mask,
                           __mem40 struct macstats_head_drop_accum *port_stats,
                           unsigned int break_cpp_burst)
{
    __gpr uint32_t addr;
    __xwrite uint64_t add_val[2];
    __gpr uint32_t drop_pair;
    __gpr int add_even;
    __gpr int add_odd;
    unsigned int i;
    int ret = 0;

    ctassert(__is_ct_const(break_cpp_burst));

    if (nbi > 1) {
        ret = -1;
        goto out;
    }
    if (core > (NFP_MAX_MAC_CORES_PER_MAC_ISL - 1)) {
        ret = -1;
        goto out;
    }

    addr = NFP_MAC_XPB_OFF(nbi);

    if (core == 0)
        addr += NFP_MAC_CSR_ETH0_IG_HEAD_DROP_CNTR_PAIR(0);
    else
        addr += NFP_MAC_CSR_ETH1_IG_HEAD_DROP_CNTR_PAIR(0);

    for (i = 0 ; i < NFP_MAX_ETH_PORTS_PER_MAC_CORE ; i+=2) {
        add_even = ports_mask & (1 << i);
        add_odd  = ports_mask & (1 << (i + 1));
        if (add_even || add_odd) {
            drop_pair = xpb_read(addr + (i << 1));
            add_val[0] = ((uint64_t)(drop_pair & 0xffff) << 32);
            add_val[1] = ((uint64_t)((drop_pair >> 16) & 0xffff) << 32);
            if (add_even)
                mem_add64(&add_val[0], &port_stats->ports_drop[i],
                          sizeof(uint64_t));
            if (add_odd)
                mem_add64(&add_val[1], &port_stats->ports_drop[i + 1],
                          sizeof(uint64_t));

            if (break_cpp_burst) {
                /* Spread the short bursts of CPP commands this loop is
                * generating to minimize DSF port utilization issues. */
                sleep(MAC_HEAD_DROP_SLEEP);
            }
        }
    }
out:
    return ret;
}

#elif defined(__NFP_IS_38XX)

__intrinsic int
__macstats_head_drop_accum(unsigned int nbi, unsigned int core,
                           unsigned short ports_mask,
                           __mem40 struct macstats_head_drop_accum *port_stats,
                           unsigned int break_cpp_burst)
{
    __gpr uint32_t addr;
    __gpr uint32_t drop_cnt;
    __xwrite uint64_t add_val;
    unsigned int i;
    int ret = 0;

    ctassert(__is_ct_const(break_cpp_burst));

    if (nbi > 1) {
        ret = -1;
        goto out;
    }
    if (core > (NFP_MAX_MAC_CORES_PER_MAC_ISL - 1)) {
        ret = -1;
        goto out;
    }

    addr = NFP_MAC_XPB_OFF(nbi);

    if (core == 0)
        addr += NFP_MAC_CSR_ETH0_IG_HEAD_DROP_CNTR(0);
    else
        addr += NFP_MAC_CSR_ETH1_IG_HEAD_DROP_CNTR(0);

    for (i = 0; i < NFP_MAX_ETH_PORTS_PER_MAC_CORE; ++i) {
        if (ports_mask & (1 << i)) {
            drop_cnt = xpb_read(addr + (i << 2));
            add_val  = (uint64_t)drop_cnt << 32;
            mem_add64(&add_val, &port_stats->ports_drop[i], sizeof(uint64_t));

            if (break_cpp_burst) {
                /* Spread the short bursts of CPP commands this loop is
                * generating to minimize DSF port utilization issues. */
                sleep(MAC_HEAD_DROP_SLEEP);
            }
        }
    }
out:
    return ret;
}

#endif /* defined(__NFP_IS_38XX) */

__intrinsic int
macstats_head_drop_accum(unsigned int nbi, unsigned int core,
                         unsigned short ports_mask,
                         __mem40 struct macstats_head_drop_accum *port_stats)
{
    return __macstats_head_drop_accum(nbi, core, ports_mask, port_stats, 0);
}
